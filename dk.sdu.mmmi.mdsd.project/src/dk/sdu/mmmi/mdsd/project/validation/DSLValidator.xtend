/*
 * generated by Xtext 2.13.0
 */
package dk.sdu.mmmi.mdsd.project.validation

import org.eclipse.xtext.EcoreUtil2
import dk.sdu.mmmi.mdsd.project.dSL.DSLPackage.Literals
import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.mdsd.project.dSL.Pickupable
import dk.sdu.mmmi.mdsd.project.dSL.UntilRobot
import dk.sdu.mmmi.mdsd.project.dSL.Robot
import dk.sdu.mmmi.mdsd.project.dSL.DoTask
import java.util.HashSet
import dk.sdu.mmmi.mdsd.project.dSL.Task
import java.util.Set
import dk.sdu.mmmi.mdsd.project.dSL.Area
import dk.sdu.mmmi.mdsd.project.dSL.AreaItem
import dk.sdu.mmmi.mdsd.project.dSL.RobotDefinition
import dk.sdu.mmmi.mdsd.project.dSL.StartPoint
import dk.sdu.mmmi.mdsd.project.dSL.WhenAtPos
import dk.sdu.mmmi.mdsd.project.dSL.Vector2
import dk.sdu.mmmi.mdsd.project.dSL.Until

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DSLValidator extends AbstractDSLValidator {
	

	public static val INVALID_NAME = 'Another shelf with the same name already exists';
	public static val INVALID_TERMINATABLE = "Two terminatables handlers can't have the same name";
	
	@Check(FAST)
	def checkNames(Pickupable s) {
		val container = EcoreUtil2.getRootContainer(s);
		val cand = EcoreUtil2.getAllContentsOfType(container, Pickupable);
		
		for (Pickupable myS : cand) {
			
			if (s != myS) {
				if (s.name.equals(myS.name)) {
					error(INVALID_NAME,  Literals.AREA_ITEM__NAME);
				}
			}

		}
	}
	
	@Check
	def checkWaitIsNotItself(UntilRobot untilRobot) {
		val robot = EcoreUtil2.getContainerOfType(untilRobot, Robot);
		if (robot === untilRobot.robot) {
			error('Robot cannot wait for itself', Literals.UNTIL_ROBOT__ROBOT)
		}
	}
	
	@Check
	def checkTaskNoCyclicDo(DoTask doTask) {
		var seen = new HashSet<String>
		var task = EcoreUtil2.getContainerOfType(doTask, Task)
		if (task.selfDo(seen)) {
			error ('Cyclic do task', Literals.DO_TASK__TASK)
		}
	}
	
	def boolean selfDo(Task next, Set<String> seen) {
		if (next === null) false
		else if (seen.contains(next.name)) true
		else { 
			seen.add(next.name)
			var dos = next.items.filter(DoTask)
			for (doTask : dos) {
				var result = doTask.task.selfDo(seen)
				if (result) return true;
			}
			return false
		}
	}
	
	@Check
	def checkNoNegativeAreaSize(Area area) {
		if (area.size.x < 1 || area.size.y < 1) {
			error('Area cannot be of size 0 or less', Literals.AREA__SIZE)
		}
	}
	
	@Check
	def checkPickupablePos(AreaItem item) {
		if (item.pos.checkOutsideArea) {
			error('Item cannot be outside area boundaries', Literals.AREA_ITEM__POS)
		}
	}
	
	@Check
	def checkRobotStartingPoint(StartPoint sp) {
		if (sp.pos.checkOutsideArea) {
			error('Cannot set startpoint outside of area', Literals.START_POINT__POS)
		}
	}
	
	@Check
	def checkWhenAtUnreachablePos(WhenAtPos when) {
		if (when.pos.checkOutsideArea) {
			warning('Position is outside area', Literals.WHEN_AT_POS__POS)
		}
	}
	
	@Check
	def checkWaitUntilPos(Until until) {
		if (until.pos.checkOutsideArea) {
			warning('Position is outside area', Literals.UNTIL__POS)
		}
	}
	
	def checkOutsideArea(Vector2 pos) {
		var area = EcoreUtil2.getContainerOfType(pos, RobotDefinition).area
		return pos.x > area.size.x || pos.y > area.size.y;
	}
}
















